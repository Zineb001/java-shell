package uk.ac.ucl.shell.cmd;

import uk.ac.ucl.shell.ShellGrammarParser;

import java.util.ArrayList;
import java.util.List;
import uk.ac.ucl.shell.ShellGrammarBaseVisitor;
import uk.ac.ucl.shell.ShellUtils;

/**
 ShellVisitor extends ShellGrammarBaseVisitor generated by ANTLR from grammar ShellGrammar.g4.
 the goal is to instantiate the class corresponding to command (Mapping String command to model).
 remember that our command is either sequence or pipe or call.
 thus, the first visit : visitCommand will qualify the context and instantiate Sequence or Pipe or Call by :
 visitSeq - visitPipe - visitCall
 */
public class ShellVisitor extends ShellGrammarBaseVisitor<Command> {
    private List<String> semanticErrors;

    public ShellVisitor(List<String> syntaxErrors) {
        this.semanticErrors = syntaxErrors;
    }

    @Override
    public Command visitCommand(ShellGrammarParser.CommandContext ctx) {
        if (ctx.seq() != null){
            return this.visitSeq(ctx.seq());
        } else if (ctx.pipe() != null) {
            return this.visitPipe(ctx.pipe());
        } else if (ctx.call() != null) {
            return this.visitCall(ctx.call());
        }
        semanticErrors.add("invalid command");
        return null;
    }

    /**
    visitSeq instantiate Sequence with simple loop on the children of the context
     */
    @Override
    public Seq visitSeq(ShellGrammarParser.SeqContext ctx) {
        if (ctx.getChildCount() <= 1){
            semanticErrors.add("invalid Sequence");
            return null;
        }

        Seq seq  = new Seq();
        for(int i = 0;i < ctx.getChildCount(); i++){
            seq.add(visit(ctx.getChild(i)));
        }
        return seq;
    }

    /**
     visitPipe instantiate Pipe recursively as declared in the grammar
     */
    @Override
    public Pipe visitPipe(ShellGrammarParser.PipeContext ctx) {
        Pipe pipe = new Pipe();
        for(int i = ctx.getChildCount()-1;i >=0; i--){
            Command c = visit(ctx.getChild(i));
            if (c instanceof Call){
                if (pipe.getCall() == null)
                    pipe.setCall((Call) c);
                else
                    pipe.setLeft(new Pipe((Call) c));

            }
            else if (c instanceof Pipe) {
                pipe.setLeft((Pipe) c);
            }
        }
        return pipe;
    }

    /**
     visitCall instantiate call by parsing arguments
     the first argument will be the application name
     eventually instantiate Redirection if exists in the context
     */
    @Override
    public Call visitCall(ShellGrammarParser.CallContext ctx) {
        List<String> args = new ArrayList<>();
        List<String> tempRedirection = new ArrayList<>();
        List<String> inRedirection = null;
        List<String> outRedirection = null;

        ShellUtils.getTreeLeaves(ctx.argument(),args);
        for (ShellGrammarParser.AtomContext a:ctx.atom() ){
            ShellUtils.getTreeLeaves(a.redirection(),tempRedirection);
            if (tempRedirection.size()>0){
                if (tempRedirection.size() > 2){
                    semanticErrors.add("invalid Number of arguments in redirection");
                    return null;
                }
                if (tempRedirection.get(0).equals("<")){
                    inRedirection = new ArrayList<>(tempRedirection);
                }
                else{
                    outRedirection = new ArrayList<>(tempRedirection);
                }
                tempRedirection.clear();
            }

        }

        if (args.size() ==0)
            return null;

        Call call = new Call(args.get(0));
        if (call.getApp()==null){
            semanticErrors.add("invalid Application in call command");
            return null;
        }
        if (args.size() > 1)
            for (int i = 1; i < args.size(); i++){
                /**
                 * remove double quote or single quote for arg staring with them
                 */
                String arg = args.get(i);

                if ((arg.startsWith("'") || arg.startsWith("\"")) && arg.length()>2) {
                        arg = arg.substring(1,arg.length()-1);
                }
                call.addArg(arg);
            }

        if (inRedirection != null && inRedirection.size()>1)
            call.addRedirection(new Redirection(inRedirection.get(0), inRedirection.get(1)));

        if (outRedirection != null && outRedirection.size()>1)
            call.addRedirection(new Redirection(outRedirection.get(0), outRedirection.get(1)));

        return call;
    }

}
